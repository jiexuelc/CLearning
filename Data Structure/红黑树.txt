数据结构“红黑树”

1.红黑树特性：
  (1) 每个节点或者是黑色，或者是红色。
  (2) 根节点是黑色。
  (3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
  (4) 如果一个节点是红色的，则它的子节点必须是黑色的。
  (5) 对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。
  
2.红黑树左旋
  条件：保证左旋节点的右孩子不为NIL(空)节点
  (1)将左旋节点右孩子的左孩子作为左旋节点右孩子
  (2)将左旋节点替换为其右孩子
  (3)将左旋节点分支插在其右孩子的左孩子节点上面
  
3.红黑树右旋
  条件：保证右旋节点的左孩子不为NIL(空)节点
  (1)将右旋节点左孩子的右孩子作为右旋节点左孩子
  (2)将右旋节点替换为其左孩子
  (3)将右旋节点分支插在其左孩子的右孩子节点上面  
注意点：左旋和右旋不改变红黑树仍然是二叉查找树的性质

4.红黑树添加
  (1)找到合适位置插入
  (2)将节点着色为红色
  (3)通过旋转和着色重新修正该树，使其重新成为一颗红黑树
    (a)当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色
      操作：将当前节点的父节点和叔叔节点涂黑，祖父结点涂红，把当前结点指向祖父节点，从新的当前节点重新开始算法
        “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。
        但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1”同时也意味着“包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题；但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。
    (b)当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子
      操作：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋
        首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。
        为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！ 
        按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。
	(c)当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子
      操作：父节点变为黑色，祖父节点变为红色，以祖父节点为支点右旋
        为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。
        S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。

5.红黑树删除
  (1)首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；
    这和"删除常规二叉查找树中删除节点的方法是一样的"。分3种情况：
      ①被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。
      ②被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。
      ③被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。这样就巧妙的将问题转换为"删除后继节点"的情况了，下面就考虑后继节点。 在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然"的后继节点"不可能双子都非空，就意味着"该节点的后继节点"要么没有儿子，要么只有一个儿子。若没有儿子，则按"情况① "进行处理；若只有一个儿子，则按"情况② "进行处理。
  (2)然后，通过"旋转和重新着色"等一系列操作修正该树，使之重新成为一棵红黑树。
    将节点删除"后，可能违反"特性(2)、(4)、(5)"三个特性。
    为了便于分析，我们假设"x包含一个额外的黑色"(x原本的颜色还存在)，这样就不会违反"特性(5)"。为什么呢？
    通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设"x包含一个额外的黑色"，就正好弥补了"删除y所丢失的黑色节点"，也就不会违反"特性(5)"。 因此，假设"x包含一个额外的黑色"(x原本的颜色还存在)，这样就不会违反"特性(5)"。
    现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是"红+黑"或"黑+黑"，它违反了"特性(1)"。
    现在，我们面临的问题，由解决"违反了特性(2)、(4)、(5)三个特性"转换成了"解决违反特性(1)、(2)、(4)三个特性"。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：
      a) x指向一个"红+黑"节点。此时，将x设为一个"黑"节点即可。
      b) x指向根。此时，将x设为一个"黑"节点即可。
      c) 非前面两种姿态
    将上面的姿态，可以概括为3种情况。
      ① 情况说明：x是“红+黑”节点。
        处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。
      ② 情况说明：x是“黑+黑”节点，且x是根。
        处理方法：什么都不做，结束。此时红黑树性质全部恢复。
      ③ 情况说明：x是“黑+黑”节点，且x不是根。
        处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：

    
